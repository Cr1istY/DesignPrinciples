## 理论

定义：SRP，其核心在于一个软件单元应仅有一个引起它变化的原因，旨在通过职责分离实现高内聚、低耦合。

作用：显著提升代码的可维护性、可测试性、可扩展性和复用性，降低系统复杂度与变更风险。
### 为什么会出现

在实际开发过程中，开发者逐渐发现，有时：

为系统添加一个新功能，或是对一个看似独立的业务模块进行修改，往往会“牵一发而动全身”，导致意想不到的错误连锁反应。最终，使得系统变得脆弱、僵硬，且维护成本极高。

### 核心主张

一个类或模块，应该并只能有一个引起它变化的原因，（即，其只负责一个职责）。

例如：一个同时处理用户数据验证、数据库持久化和发送欢迎邮件的`UserService`类，就违反了单一职责原则。

又例如：一个订单类若同时负责计算总价（变化原因：计价规则调整）和生成PDF报表（变化原因：报表格式修改），即使这两个功能都与订单相关，也违反了SRP。

### 解决的问题

传统代码的腐化几乎成为一种自然趋势，具体表现为：

1. 僵硬性：一个简单的改动需要牵连多个地方进行连锁修改。
2. 脆弱性：修改一处代码会引发另一处看似无关的代码产生错误。
3. 牢固性：系统中紧密耦合的部分，难以被抽取和复用。
4. 粘滞性：由于代码重构的代价过高，迫使开发者采用补丁式修复的错误方案。

### 实际场景分析

#### 传统应用开发：Web、移动、桌面端的模块设计

1. Web：经典的分层架构（如MVC）

#### 现代架构实践：微服务、云原生于领域驱动设计

1. 微服务：例如，在一个大型电商系统中，用户微服务仅用于用户注册、登录、信息管理。

### 具体使用

- 核心判断依据：变化的缘由，即——一个类只能有一个引起它变化的原因。
- 违法单一职责原则的信号：
    - 类名模糊不清
    - 代码行数与私有方法过多
    - 依赖关系复杂
    - 测试难度陡增
    - 方法集中操作特点属性

重构步骤：
1. 分析诊断与职责提取。
2. 接口抽象与职责封装。
3. 依赖注入与协调器注入。
4. 测试与迭代验证。

避免：
1. 过度拆分；
2. 伪职责分离。